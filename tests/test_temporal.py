import pandas as pd
import pytest
import gingado.temporal as tp


@pytest.fixture(name="sample_df")
def sample_df_fixture() -> pd.DataFrame:
    """Create a sample DataFrame with a DatetimeIndex for testing."""

    date_range = pd.date_range(start="2023-01-01", end="2024-12-31", freq="D")
    return pd.DataFrame({"value": range(len(date_range))}, index=date_range)


@pytest.fixture(name="daily_df")
def daily_df_fixture() -> pd.DataFrame:
    """Create a sample DataFrame with daily frequency for testing."""

    date_range = pd.date_range(start="2023-01-01", end="2023-12-31", freq="D")
    return pd.DataFrame({"value": range(len(date_range))}, index=date_range)


@pytest.fixture(name="monthly_start_df")
def monthly_start_df_fixture() -> pd.DataFrame:
    """Create a sample DataFrame with monthly frequency for testing."""

    date_range = pd.date_range(start="2023-01-01", end="2023-12-31", freq="MS")
    return pd.DataFrame({"value": range(len(date_range))}, index=date_range)


@pytest.fixture(name="quarterly_start_df")
def quarterly_start_df_fixture() -> pd.DataFrame:
    """Create a sample DataFrame with quarterly frequency for testing."""

    date_range = pd.date_range(start="2023-01-01", end="2024-12-31", freq="QS")
    return pd.DataFrame({"value": range(len(date_range))}, index=date_range)


def test_frequency_enum_values():
    """Test that Frequency enum has correct values."""
    assert tp.Frequency.DAILY.value == "D"
    assert tp.Frequency.WEEKLY.value == "W"
    assert tp.Frequency.MONTHLY.value == "MS"
    assert tp.Frequency.QUARTERLY.value == "QS"


@pytest.mark.parametrize("input_freq, expected", [("D", "D"), ("w", "W"), ("M", "M"), ("qs", "QS")])
def test_validate_and_get_freq_valid_inputs(input_freq, expected):
    """Test validate_and_get_freq with valid inputs."""
    assert tp.validate_and_get_freq(input_freq) == expected


@pytest.mark.parametrize("invalid_freq", ["INVALID", "DAY", "5"])
def test_validate_and_get_freq_invalid_inputs(invalid_freq):
    """Test validate_and_get_freq with invalid inputs."""
    with pytest.raises(ValueError):
        tp.validate_and_get_freq(invalid_freq)


def test_validate_and_get_freq_pandas_compatibility():
    """Test that returned frequencies are compatible with pandas."""
    for freq in tp.Frequency:
        offset = pd.tseries.frequencies.to_offset(freq.value)
        assert offset is not None
        assert str(offset) == freq.value


def test_get_timefeat_add_to_df(sample_df: pd.DataFrame) -> None:
    """Test get_timefeat function when add_to_df is True."""
    result = tp.get_timefeat(sample_df, add_to_df=True)
    assert len(result.columns) == len(sample_df.columns) + 12  # Original column + 12 time features
    assert len(result) == len(sample_df)  # Same number of rows as before
    assert "value" in result.columns
    assert "day_of_week" in result.columns


def test_get_timefeat_return_only_features(sample_df: pd.DataFrame) -> None:
    """Test get_timefeat function when add_to_df is False."""
    result = tp.get_timefeat(sample_df, add_to_df=False)
    assert len(result.columns) == 12  # Only time features
    assert len(result) == len(sample_df)  # Same number of rows as before
    assert "value" not in result.columns
    assert "day_of_week" in result.columns


def test_get_timefeat_invalid_index() -> None:
    """Test get_timefeat function with an invalid DataFrame index."""
    invalid_df = pd.DataFrame({"value": range(10)})
    with pytest.raises(ValueError):
        tp.get_timefeat(invalid_df)


def test_feature_values(sample_df: pd.DataFrame) -> None:
    """Test specific feature values generated by get_timefeat"""
    result = tp.get_timefeat(sample_df, add_to_df=False)
    assert result.loc["2023-01-01", "day_of_week"] == 6  # Sunday
    assert result.loc["2023-01-01", "day_of_month"] == 1
    assert result.loc["2023-01-01", "day_of_year"] == 1
    assert result.loc["2023-01-01", "week_of_month"] == 1
    assert result.loc["2023-01-01", "month_of_year"] == 1
    assert result.loc["2023-03-31", "quarter_end"] == 1
    assert result.loc["2023-12-31", "year_end"] == 1


def test_drop_zero_variance_daily(daily_df: pd.DataFrame) -> None:
    """Test drop_zero_variance parameter with daily frequency data."""
    result_with_drop = tp.get_timefeat(daily_df, add_to_df=False, drop_zero_variance=True)
    result_without_drop = tp.get_timefeat(daily_df, add_to_df=False, drop_zero_variance=False)

    # All features should be relevant for daily data
    assert len(result_with_drop.columns) == len(result_without_drop.columns)
    assert set(result_with_drop.columns) == set(result_without_drop.columns)


def test_drop_zero_variance_monthly(monthly_start_df: pd.DataFrame) -> None:
    """Test drop_zero_variance parameter with monthly frequency data."""
    result_with_drop = tp.get_timefeat(monthly_start_df, add_to_df=False, drop_zero_variance=True)
    result_without_drop = tp.get_timefeat(
        monthly_start_df, add_to_df=False, drop_zero_variance=False
    )

    # Some features should be dropped for monthly data
    assert len(result_with_drop.columns) < len(result_without_drop.columns)

    # Check specific columns that should be dropped
    assert "day_of_month" not in result_with_drop.columns
    assert "week_of_month" not in result_with_drop.columns

    # Check specific columns that should be retained
    assert "month_of_year" in result_with_drop.columns
    assert "quarter_of_year" in result_with_drop.columns


def test_drop_zero_variance_quarterly(quarterly_start_df: pd.DataFrame) -> None:
    """Test drop_zero_variance parameter with quarterly frequency data."""
    result_with_drop = tp.get_timefeat(quarterly_start_df, add_to_df=False, drop_zero_variance=True)
    result_without_drop = tp.get_timefeat(
        quarterly_start_df, add_to_df=False, drop_zero_variance=False
    )

    # Many features should be dropped for quarterly data
    assert len(result_with_drop.columns) < len(result_without_drop.columns)

    # Check specific columns that should be dropped
    assert "day_of_month" not in result_with_drop.columns
    assert "week_of_month" not in result_with_drop.columns
    assert "month_of_quarter" not in result_with_drop.columns

    # Check columns that should be retained
    assert "quarter_of_year" in result_with_drop.columns


def test_day_features(sample_df: pd.DataFrame) -> None:
    """Test the get_day_features function."""
    result = tp._get_day_features(sample_df.index)
    assert result.index.equals(sample_df.index)
    assert "day_of_week" in result.columns
    assert "day_of_month" in result.columns
    assert "day_of_quarter" in result.columns
    assert "day_of_year" in result.columns


def test_day_features_specific_values(sample_df: pd.DataFrame) -> None:
    """Test specific values for day features."""
    result = tp._get_day_features(sample_df.index)

    # Test for the first day of the year
    assert result.loc["2023-01-01", "day_of_week"] == 6  # Sunday
    assert result.loc["2023-01-01", "day_of_month"] == 1
    assert result.loc["2023-01-01", "day_of_quarter"] == 1
    assert result.loc["2023-01-01", "day_of_year"] == 1

    # Test for the last day of the year
    assert result.loc["2023-12-31", "day_of_week"] == 6  # Sunday
    assert result.loc["2023-12-31", "day_of_month"] == 31
    assert result.loc["2023-12-31", "day_of_quarter"] == 92
    assert result.loc["2023-12-31", "day_of_year"] == 365

    # Test for a leap year day
    assert result.loc["2024-02-29", "day_of_week"] == 3  # Thursday
    assert result.loc["2024-02-29", "day_of_month"] == 29
    assert result.loc["2024-02-29", "day_of_quarter"] == 60
    assert result.loc["2024-02-29", "day_of_year"] == 60

    # Test for the last day of a leap year
    assert result.loc["2024-12-31", "day_of_year"] == 366


def test_week_features(sample_df: pd.DataFrame) -> None:
    """Test the get_week_features function."""
    result = tp._get_week_features(sample_df.index)
    assert result.index.equals(sample_df.index)

    assert "week_of_month" in result.columns
    assert "week_of_quarter" in result.columns
    assert "week_of_year" in result.columns


def test_week_features_specific_values(sample_df: pd.DataFrame) -> None:
    """Test specific values for week features."""
    result = tp._get_week_features(sample_df.index)

    # Test for the first week of the year
    assert result.loc["2023-01-01", "week_of_month"] == 1
    assert result.loc["2023-01-01", "week_of_quarter"] == 1
    assert result.loc["2023-01-01", "week_of_year"] == 52  # Last week of previous year

    # Test for a mid-year week
    assert result.loc["2023-07-15", "week_of_month"] == 3
    assert result.loc["2023-07-15", "week_of_quarter"] == 3
    assert result.loc["2023-07-15", "week_of_year"] == 28

    # Test for the last week of the year
    assert result.loc["2023-12-31", "week_of_month"] == 5
    assert result.loc["2023-12-31", "week_of_quarter"] == 14
    assert result.loc["2023-12-31", "week_of_year"] == 52

    # Test for a leap year
    assert result.loc["2024-02-29", "week_of_month"] == 5
    assert result.loc["2024-02-29", "week_of_quarter"] == 9
    assert result.loc["2024-02-29", "week_of_year"] == 9


def test_month_features(sample_df: pd.DataFrame) -> None:
    """Test the get_month_features function."""
    result = tp._get_month_features(sample_df.index)
    assert result.index.equals(sample_df.index)
    assert "month_of_quarter" in result.columns
    assert "month_of_year" in result.columns


def test_month_features_specific_values(sample_df: pd.DataFrame) -> None:
    """Test specific values for month features."""
    result = tp._get_month_features(sample_df.index)

    # Test for January (first month of year and quarter)
    assert result.loc["2023-01-15", "month_of_quarter"] == 1
    assert result.loc["2023-01-15", "month_of_year"] == 1

    # Test for June (last month of Q2)
    assert result.loc["2023-06-15", "month_of_quarter"] == 3
    assert result.loc["2023-06-15", "month_of_year"] == 6

    # Test for December (last month of year and quarter)
    assert result.loc["2023-12-15", "month_of_quarter"] == 3
    assert result.loc["2023-12-15", "month_of_year"] == 12

    # Test for February in a leap year
    assert result.loc["2024-02-29", "month_of_quarter"] == 2
    assert result.loc["2024-02-29", "month_of_year"] == 2


def test_quarter_features(sample_df: pd.DataFrame) -> None:
    """Test the get_quarter_features function."""
    result = tp._get_quarter_features(sample_df.index)
    assert result.index.equals(sample_df.index)
    assert "quarter_of_year" in result.columns
    assert "quarter_end" in result.columns
    assert "year_end" in result.columns


def test_quarter_features_specific_values(sample_df: pd.DataFrame) -> None:
    """Test specific values for quarter features."""
    result = tp._get_quarter_features(sample_df.index)
    # Test for first day of Q1
    assert result.loc["2023-01-01", "quarter_of_year"] == 1
    assert result.loc["2023-01-01", "quarter_end"] == 0
    assert result.loc["2023-01-01", "year_end"] == 0

    # Test for last day of Q1
    assert result.loc["2023-03-31", "quarter_of_year"] == 1
    assert result.loc["2023-03-31", "quarter_end"] == 1
    assert result.loc["2023-03-31", "year_end"] == 0

    # Test for first day of Q4
    assert result.loc["2023-10-01", "quarter_of_year"] == 4
    assert result.loc["2023-10-01", "quarter_end"] == 0
    assert result.loc["2023-10-01", "year_end"] == 0

    # Test for last day of Q4 (also year end)
    assert result.loc["2023-12-31", "quarter_of_year"] == 4
    assert result.loc["2023-12-31", "quarter_end"] == 1
    assert result.loc["2023-12-31", "year_end"] == 1

    # Test for leap year
    assert result.loc["2024-02-29", "quarter_of_year"] == 1
    assert result.loc["2024-02-29", "quarter_end"] == 0
    assert result.loc["2024-02-29", "year_end"] == 0
